<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><meta name=description content="Mark's Site"><title>Setting up project specific tools using Nix - Hello, I&rsquo;m Mark</title><link rel="shortcut icon" href=/m.ico><link rel=stylesheet href=/css/main.min.c5514d3530979d291f3497facc20da1cec870028dbc2a3630b64bab8721bbe49.css integrity="sha256-xVFNNTCXnSkfNJf6zCDaHOyHACjbwqNjC2S6uHIbvkk=" crossorigin=anonymous media=screen><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Didact+Gothic"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://markc.su/tn.png"><meta name=twitter:title content="Setting up project specific tools using Nix"><meta name=twitter:description content="Over my past blog posts, I&rsquo;ve made it clear that I enjoy how much I like setting up all my projects in the declarative way of Nix. In this article, I will go more in detail on how exactly I have direnv set up to automatically load my tools when I hop into a project.
In my last article I talked about how I don&rsquo;t have most of my programs installed globally, but instead, I have it set up so that whenever I jump into one of my project directories it automatically loads the correct packages and tools into my terminal environment."><meta property="og:title" content="Setting up project specific tools using Nix"><meta property="og:description" content="Over my past blog posts, I&rsquo;ve made it clear that I enjoy how much I like setting up all my projects in the declarative way of Nix. In this article, I will go more in detail on how exactly I have direnv set up to automatically load my tools when I hop into a project.
In my last article I talked about how I don&rsquo;t have most of my programs installed globally, but instead, I have it set up so that whenever I jump into one of my project directories it automatically loads the correct packages and tools into my terminal environment."><meta property="og:type" content="article"><meta property="og:url" content="https://markc.su/posts/nix-direnv-setup/"><meta property="og:image" content="https://markc.su/tn.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-09T09:47:41+02:00"><meta property="article:modified_time" content="2023-06-09T09:47:41+02:00"><meta property="og:site_name" content="Hello, I'm Mark"><title>Setting up project specific tools using Nix</title></head><body><header class="wrap flex-container"><h1>Setting up project specific tools using Nix</h1></header><main class=wrap><div class=flex-container><aside role=complementary>Fri Jun 09, 2023 &#183; 909 words<div class=tag-container><span class=tag><a href=/tags/programming/>programming</a></span>
<span class=tag><a href=/tags/nix/>nix</a></span>
<span class=tag><a href=/tags/direnv/>direnv</a></span></div></aside><hr><article role=article><p>Over my past blog posts, I&rsquo;ve made it clear that I enjoy how much I like
setting up all my projects in the declarative way of Nix. In this article, I
will go more in detail on how exactly I have <code>direnv</code> set up to automatically
load my tools when I hop into a project.</p><p>In my <a href=/posts/nix-direnv-setup>last article</a> I talked about how I don&rsquo;t have
most of my programs installed globally, but instead, I have it set up so that
whenever I jump into one of my project directories it automatically loads the
correct packages and tools into my terminal environment. Since I discovered
<code>direnv</code> 4 months ago I&rsquo;ve been using it for all my projects.</p><h1 id=the-idea class=anchor-link><a href=#the-idea>The Idea<span class=pilcrow>&nbsp;¶</span></a></h1><p>The basic idea of how I have everything set up is that globally I barely have
anything installed. Only tools I use a lot or don&rsquo;t want to install anew every time I wanna use them. This includes applications like Firefox,
Neovim, Kitty, etc. Everything else related to programming or tools I only need
for a one-time use I install differently.</p><p>Tools that I only need for one-time use, say I want to quickly run <code>dig</code> to
figure out what IP a domain points to or I quickly try something out in GIMP, I
open up my terminal and run <code>nix-shell -p dig</code> (or <code>gimp</code>). Then I run the use tool and
when I&rsquo;m done I&rsquo;ll simply close the terminal and let the Nix garbage collector
clean up anything I installed. The garbage collector runs automatically on a daily basis.</p><h1 id=the-execution class=anchor-link><a href=#the-execution>The Execution<span class=pilcrow>&nbsp;¶</span></a></h1><p>To get everything to work I use <a href=https://github.com/nix-community/lorri>lorri</a>. It extends <a href=https://direnv.net/>direnv</a> to add some features specific to Nix.</p><h2 id=direnv class=anchor-link><a href=#direnv>direnv<span class=pilcrow>&nbsp;¶</span></a></h2><p><a href=https://direnv.net/>direnv</a> is a tool that allows you to automatically load and unload environment variables depending on the directory you&rsquo;re in.
Simply add <code>direnv</code> to your configuration.nix, home manager or nix-env packages:</p><p>On NixOS:</p><pre tabindex=0><code>environment.systemPackages = [
    pkgs.direnv
];
</code></pre><p>On non-NixOS:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nix-env -iA nixpkgs.direnv
</span></span></code></pre></div><p>Now enter a directory, create a file called <code>.envrc</code> and add some export.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># .envrc</span>
</span></span><span style=display:flex><span>export HELLO<span style=color:#f92672>=</span><span style=color:#ae81ff>123</span>
</span></span></code></pre></div><p>direnv initially blocks a <code>.envrc</code> file upon its creation or upon being changed. You first need to allow it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>direnv allow
</span></span></code></pre></div><p>direnv now automatically loads the export (which can be confirmed with <code>echo $HELLO</code>). How cool is that?
When you exit the directory the export will automatically be unloaded again.</p><h2 id=shellnix class=anchor-link><a href=#shellnix>shell.nix<span class=pilcrow>&nbsp;¶</span></a></h2><p>It can quickly become tedious to always install tools using the above <code>nix shell</code> if need to install a lot of things.
To make it easier you can create a <code>shell.nix</code> file and specify what packages should be installed and what commands should be executed in the shell.</p><p>A barebones <code>shell.nix</code> is as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{ pkgs <span style=color:#f92672>?</span> <span style=color:#f92672>import</span> <span style=color:#e6db74>&lt;nixpkgs&gt;</span> {} }:
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> pkgs;
</span></span><span style=display:flex><span>mkShell {
</span></span><span style=display:flex><span>  buildInputs <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    python311
</span></span><span style=display:flex><span>    poetry
</span></span><span style=display:flex><span>    postgresql_15
</span></span><span style=display:flex><span>  ];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To get into this shell simply execute <code>nix-shell</code>. If the file is in another directory you can also specify the file with the <code>-f</code> flag. This will install all the listed programs and set you into a new environment.</p><p>But we want this automated; by adding <code>use nix</code> to the <code>.envrc</code> file direnv will now automatically load this <code>shell.nix</code> file whenever you enter the directory, automatically giving you access to Python 3.11, Poetry and Postgresql. When you exit the directory they will all be unloaded from your shell environment.</p><h2 id=lorri class=anchor-link><a href=#lorri>lorri<span class=pilcrow>&nbsp;¶</span></a></h2><p>Now you might notice that jumping into the directory can start to get really slow once your <code>shell.nix</code> file grows to a lot of packages. Especially after you run the Nix garbage collector, because then everything has to be downloaded anew.</p><p>That is what <a href=https://github.com/nix-community/lorri>lorri</a> solves. Lorri adds two game-changing changes:</p><ol><li>shell.nix environments are cached. That makes loading into big projects very quick. You don&rsquo;t even notice that something is happening anymore (ignoring the big message appearing in the terminal).</li><li>All installed packages are marked to not be garbage collected. Now you can garbage collect without having to worry about deleting all the packages you need for a project.</li></ol><p>This is all handled completely automatically. All you need to do is initialize your <code>.envrc</code> file by running <code>lorri init</code>, so that lorri is correctly ran upon entering the directory.</p><p>Additionally, when you delete a project or shell.nix, remember to also run <code>lorri gc</code> to remove all the links so that the Nix garbage collector will delete the unused packages.</p><h1 id=the-truth class=anchor-link><a href=#the-truth>The Truth<span class=pilcrow>&nbsp;¶</span></a></h1><p>What motivated me to write this blog post was that I actually started to finally get into what Nix flakes are and how they work. Explained very roughly, they are a new thing from Nix that upgrades the reproducibility for everything. It takes inspiration from other project-based package managers like npm or <a href=https://python-poetry.org/>Poetry</a> which generate a lock file to make everything you do extremely reproducible.
Have a look at this <a href=https://woile.dev/posts/nix-journey-part-1-creating-a-flake/>introduction to flakes</a> blog post or a nice <a href=https://blog.ysndr.de/posts/guides/2021-12-01-nix-shells/>article</a> that talks about some of the new commands.</p><p>As of now I&rsquo;m &ldquo;flaking&rdquo; my projects and moving them from <code>shell.nix</code> projects to proper flake projects. After 4 months of using lorri I&rsquo;ve now moved on to another tool because lorri doesn&rsquo;t support flakes. The exact benefits, why I moved over and how you can set it up will be a future blog post once I got some more experience with flakes.</p><p>A small teaser; flakes allow you to simply use <code>nix develop github:markbeep/markbeep.github.io</code> to get all the tools I use for working on this blog (basically just <a href=https://gohugo.io/>hugo</a>) without even having to clone the project.</p></div></article></div><nav role=navigation class="flex-container bottom-menu"><hr><p><script src=https://utteranc.es/client.js repo=markbeep/markbeep.github.io issue-term=pathname label=comments theme=dark-blue crossorigin=anonymous async></script><a href=/posts>back</a>
&#183;
<a href=/posts>posts</a>
&#183;
<a href=https://github.com/markbeep>github</a>
&#183;
<a href=/polyring>polyring</a>
&#183;
<a href=/about>who is mark?</a>
&#183;
<a href=/>main</a></p></nav></main><footer class="flex-container footer">Call me Sam, a theme for Hugo.</footer></body></html>