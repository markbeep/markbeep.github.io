<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><meta name=description content="Mark's Site"><title>Creating a Thread Pool in C - Hello, I&rsquo;m Mark</title><link rel="shortcut icon" href=/m.ico><link rel=stylesheet href=/css/main.min.8022aa4b53ce57ff6f9cc4594360bfc15f2baeb5a018d0c68826f12da49a51e0.css integrity="sha256-gCKqS1POV/9vnMRZQ2C/wV8rrrWgGNDGiCbxLaSaUeA=" crossorigin=anonymous media=screen><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Didact+Gothic"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://markc.su/tn.png"><meta name=twitter:title content="Creating a Thread Pool in C"><meta name=twitter:description content="Table of Contents&nbsp;¶  Why a thread pool in C? Basic Layout Implementation  Work Node Thread Pool Functions  t_pool_init thread_work_loop t_pool_add_work t_pool_pop_work t_pool_destroy t_process_count     Using the thread pool Final words  Why a thread pool in C?&nbsp;¶ For the past few weeks, I&rsquo;ve been working on a Discord bot library written in C called Disco-C. It allows for people to easily write their own Discord bots all in C."><meta property="og:title" content="Creating a Thread Pool in C"><meta property="og:description" content="Table of Contents&nbsp;¶  Why a thread pool in C? Basic Layout Implementation  Work Node Thread Pool Functions  t_pool_init thread_work_loop t_pool_add_work t_pool_pop_work t_pool_destroy t_process_count     Using the thread pool Final words  Why a thread pool in C?&nbsp;¶ For the past few weeks, I&rsquo;ve been working on a Discord bot library written in C called Disco-C. It allows for people to easily write their own Discord bots all in C."><meta property="og:type" content="article"><meta property="og:url" content="https://markc.su/posts/threadpool_c/"><meta property="og:image" content="https://markc.su/tn.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-24T09:09:47+02:00"><meta property="article:modified_time" content="2022-05-24T09:09:47+02:00"><meta property="og:site_name" content="Hello, I'm Mark"><title>Creating a Thread Pool in C</title></head><body><header class="wrap flex-container"><h1>Creating a Thread Pool in C</h1></header><main class=wrap><div class=flex-container><aside role=complementary>Tue May 24, 2022 &#183; 2701 words<div class=tag-container><span class=tag><a href=/tags/c/>c</a></span>
<span class=tag><a href=/tags/multithreading/>multithreading</a></span>
<span class=tag><a href=/tags/discord/>discord</a></span></div></aside><hr><article role=article><div style=text-align:justify><h1 id=table-of-contents class=anchor-link><a href=#table-of-contents>Table of Contents<span class=pilcrow>&nbsp;¶</span></a></h1><ul><li><a href=#why-a-thread-pool-in-c>Why a thread pool in C?</a></li><li><a href=#basic-layout>Basic Layout</a></li><li><a href=#implementation>Implementation</a><ul><li><a href=#work-node>Work Node</a></li><li><a href=#thread-pool>Thread Pool</a></li><li><a href=#functions>Functions</a><ul><li><a href=#tpoolinit>t_pool_init</a></li><li><a href=#thread_work_loop>thread_work_loop</a></li><li><a href=#t_pool_add_work>t_pool_add_work</a></li><li><a href=#t_pool_pop_work>t_pool_pop_work</a></li><li><a href=#t_pool_destroy>t_pool_destroy</a></li><li><a href=#t_process_count>t_process_count</a></li></ul></li></ul></li><li><a href=#using-the-thread-pool>Using the thread pool</a></li><li><a href=#final-words>Final words</a></li></ul><h1 id=why-a-thread-pool-in-c class=anchor-link><a href=#why-a-thread-pool-in-c>Why a thread pool in C?<span class=pilcrow>&nbsp;¶</span></a></h1><p>For the past few weeks, I&rsquo;ve been working on a Discord bot library written in C called <a href=https://github.com/markbeep/Disco-C/>Disco-C</a>. It allows for people to easily write their own Discord bots all in C. It is a nice project that allows me to use a lot of different things that I learned the past 4 semesters, but this bot is for a different blog post. Upon working on it I stumbled upon a big bottleneck: The HTTP requests I do to send or edit a message on Discord. While parsing the incoming data, turning it into structures and doing everything else that&rsquo;s needed takes shy of 50μs, sending the actual request takes around 300'000μs (300ms). Sometimes it drops down to 150ms, but it is clear that this is a major bottleneck of the library. The problem is that if I now run my event loop sequentially any HTTP requests I execute stall up all other commands. The solution? Multithreading? Well yes, but not exactly. It allows us to process multiple received messages at the same time. But simply creating a new thread on each event causes a lot of overhead for the creation and deletion of the threads. This is where a thread pool comes into play. In a thread pool, we create a defined amount of worker threads upon initialization and keep using these same threads for all the work we send to the pool. This saves us a lot of overhead from the thread creation.</p><p>This is why I decided to use a thread pool myself and as with a lot of things in C, if there&rsquo;s no big official library for it and you don&rsquo;t want to use some random shady Github code, you have to implement the library yourself. I never really thought about how thread pools work and at first thought, this will be a challenging task, but I was relieved to find out that it was a lot easier than I expected.</p><p>This blog post is a bit on the longer side, but it goes into detail on how all the functions work in the thread pool implementation, so you can implement it yourself if you wanted to. The inspiration for this kind of thread pool implementation I got from <a href=https://nachtimwald.com/2019/04/12/thread-pool-in-c/>this blog post</a>. They also go into a bit more in detail and have another blog post where they show how to make this implementation also work on Windows.</p><h1 id=basic-layout class=anchor-link><a href=#basic-layout>Basic Layout<span class=pilcrow>&nbsp;¶</span></a></h1><p>The way our thread pool will work is by having a queue that contains all the work that has to be done. A piece of work is defined as a function and the data that will be passed into that function.</p><p>The idea is that every time we have some new work to be done, we add the data and the corresponding function into our queue. The threads of our pool then fight a free-for-all to get the work and execute it. The work threads each constantly check for new work and once they&rsquo;re done with their current work, they instantly continue on new work if there&rsquo;s any. To avoid excessive CPU usage the threads will also be put to sleep and woken up when needed.</p><h1 id=implementation class=anchor-link><a href=#implementation>Implementation<span class=pilcrow>&nbsp;¶</span></a></h1><p>The following chapter is all about how the thread pool is exactly implemented in case you also want to try implementing it yourself.</p><p>The full implementations can be found here if you ever want a full overview: <a href=https://github.com/markbeep/Disco-C/blob/master/libs/utils/t_pool.h>Header</a> & <a href=https://github.com/markbeep/Disco-C/blob/master/libs/utils/t_pool.c>Source</a></p><h2 id=work-node class=anchor-link><a href=#work-node>Work Node<span class=pilcrow>&nbsp;¶</span></a></h2><p>For the implementation we start in our header file: <code>t_pool.h</code> with the layout of a work node:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>void</span> (<span style=color:#f92672>*</span>t_func)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>);

<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> t_work {
    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>arg;
    t_func func;
    t_work_t <span style=color:#f92672>*</span>next;
} t_work_t;
</code></pre></div><p>Our work node structure consists of the data (<code>void *arg</code>), the function and the next node in the queue. <code>arg</code> is what will be passed into the function. <code>t_func</code>is a function that takes in a pointer to the data (<code>void *</code>), but returns nothing (<code>void</code>). This means we can actually pass in any type of data type as long as the corresponding function correctly casts the data.</p><h2 id=thread-pool class=anchor-link><a href=#thread-pool>Thread Pool<span class=pilcrow>&nbsp;¶</span></a></h2><p>Now we come to a bigger structure, the actual thread pool structure:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> t_pool {
    <span style=color:#75715e>// work queue
</span><span style=color:#75715e></span>    t_work_t <span style=color:#f92672>*</span>first_work;
    t_work_t <span style=color:#f92672>*</span>last_work;
    <span style=color:#66d9ef>int</span> work_count;   <span style=color:#75715e>// amount of active work load
</span><span style=color:#75715e></span>    <span style=color:#75715e>// thread handling
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> thread_count; <span style=color:#75715e>// amount of active threads
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> stop;         <span style=color:#75715e>// bool if threads should stop
</span><span style=color:#75715e></span>    pthread_mutex_t <span style=color:#f92672>*</span>lock;
    pthread_cond_t <span style=color:#f92672>*</span>work_cond;
    pthread_cond_t <span style=color:#f92672>*</span>finished_cond;
} t_pool_t;
</code></pre></div><p>The pool struct can be split up into two parts. The first part is simply a queue with all of the work nodes. To make inserts in O(1) we need the head and tail of the queue, which is what we have the attributes <code>first_work</code> and <code>last_work</code> for. <code>work_count</code> simply states how many work nodes we currently have in the queue. In the end, we&rsquo;ll want threads to wake up, check if there&rsquo;s any work using this variable and if there&rsquo;s none, go back to sleep.</p><p>The second part is all about managing the threads. When looking at the struct you might notice that there&rsquo;s actually no array with the threads. In fact, I don&rsquo;t store any pointer to the threads. That is because I handle all the threads differently.</p><p>We first have the <code>thread_count</code> to signal how many threads are currently running. This allows us to later wait for all threads to close and keep a count of how many threads we are still waiting for. The next attribute is the boolean <code>stop</code> flag. If we want to close all threads, we can simply set this to true and it makes the threads close themselves. To make the whole pool thread-safe we have a single <code>lock</code> that we use at certain places to avoid undefined behavior like two threads writing to the same space in memory at the same time. In the end, we have two conditions <code>work_cond</code> and <code>finished_cond</code>. These are variables used to signal threads to wake up when they&rsquo;re sleeping. For people that have experience with multithreading in Java, this is what&rsquo;s used to later achieve the <code>notify</code> and <code>wait</code> methods in Java. With the pthread library, we have the advantage of not just waking up threads sleeping on a lock, but instead only waking up threads with the correct condition variable.</p><h2 id=functions class=anchor-link><a href=#functions>Functions<span class=pilcrow>&nbsp;¶</span></a></h2><p>We now define all the public functions that should exist for the thread pool.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C>t_pool_t <span style=color:#f92672>*</span><span style=color:#a6e22e>t_pool_init</span>(<span style=color:#66d9ef>int</span> num_t);
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>t_pool_add_work</span>(t_pool_t <span style=color:#f92672>*</span>tp, t_func func, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>work);
t_work_t <span style=color:#f92672>*</span><span style=color:#a6e22e>t_pool_pop_work</span>(t_pool_t <span style=color:#f92672>*</span>tp);
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>t_pool_wait</span>(t_pool_t <span style=color:#f92672>*</span>tp);
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>t_pool_destroy</span>(t_pool_t <span style=color:#f92672>*</span>tp);
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>t_process_count</span>();
</code></pre></div><ul><li><code>t_pool_init</code>: This function is to initialize the thread pool with <code>num_t</code> threads. It should return a correct setup <code>t_pool</code> struct.</li><li><code>t_pool_add_work</code>: Here we pass in our thread pool, a function and the data we want to be executed by the function. This function will then create a <code>t_work</code> node and add it to the queue. All in a thread-safe manner.</li><li><code>t_pool_pop_work</code>: This should correctly pop the first element of the queue (the next work to be done) if there is any. A thread wanting to do work will then call this function to get new work.</li><li><code>t_pool_wait</code>: This function we use simply to wait for all threads to close. If we don&rsquo;t specify the states to close beforehand, this function will wait forever.</li><li><code>t_pool_destroy</code>: Function to clean up all the allocated memory of the thread pool.</li><li><code>t_process_count</code>: Simple helper function to get the number of processes on the current machine. This can then be used to decide how many threads should be created.</li></ul><p>These are all the functions that are required to create a working thread pool. Now we&rsquo;ll go into more detail on how all of these functions actually work.</p><h3 id=t_pool_init class=anchor-link><a href=#t_pool_init>t_pool_init<span class=pilcrow>&nbsp;¶</span></a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C>t_pool_t <span style=color:#f92672>*</span><span style=color:#a6e22e>t_pool_init</span>(<span style=color:#66d9ef>int</span> num_t) {
    t_pool_t <span style=color:#f92672>*</span>pool <span style=color:#f92672>=</span> malloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> t_pool));
    <span style=color:#75715e>/* initialization left out for simplicity */</span> 
    pthread_t <span style=color:#66d9ef>thread</span>;
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> num_t; i<span style=color:#f92672>++</span>) {
        pthread_create(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>thread</span>, NULL, <span style=color:#f92672>&amp;</span>thread_work_loop, (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)pool);
        pthread_detach(<span style=color:#66d9ef>thread</span>);
    }
    <span style=color:#66d9ef>return</span> pool;
}
</code></pre></div><p>In this code snippet, I let out a big part which was just the struct initialization. The whole function can be viewed <a href=https://github.com/markbeep/Disco-C/blob/master/libs/utils/t_pool.c#L31-L55>here</a>.</p><p>The most important part of this function is the thread-creation. We create <code>num_t</code> amount of threads all with the <code>thread_work_loop</code> function (more explained later). This is a function that makes the threads simply loop forever and check for new work until told to stop. We then detach each of the threads, because we&rsquo;ll not be joining them later on and this frees the memory that gets allocated for it.</p><h3 id=thread_work_loop class=anchor-link><a href=#thread_work_loop>thread_work_loop<span class=pilcrow>&nbsp;¶</span></a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>thread_work_loop</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>tp) {
    t_pool_t <span style=color:#f92672>*</span>pool <span style=color:#f92672>=</span> (t_pool_t <span style=color:#f92672>*</span>)tp;
    <span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>) {
        pthread_mutex_lock(pool<span style=color:#f92672>-&gt;</span>lock);
        <span style=color:#66d9ef>while</span> (pool<span style=color:#f92672>-&gt;</span>work_count <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>pool<span style=color:#f92672>-&gt;</span>stop) {
            pthread_cond_wait(pool<span style=color:#f92672>-&gt;</span>work_cond, pool<span style=color:#f92672>-&gt;</span>lock);
        }
        <span style=color:#66d9ef>if</span> (pool<span style=color:#f92672>-&gt;</span>stop) {
            pool<span style=color:#f92672>-&gt;</span>thread_count<span style=color:#f92672>--</span>;
            pthread_cond_signal(pool<span style=color:#f92672>-&gt;</span>finished_cond);
            pthread_mutex_unlock(pool<span style=color:#f92672>-&gt;</span>lock);
            <span style=color:#66d9ef>break</span>;
        }
        <span style=color:#75715e>// here work_count &gt; 0
</span><span style=color:#75715e></span>        t_work_t <span style=color:#f92672>*</span>work <span style=color:#f92672>=</span> t_pool_pop_work(pool);

        <span style=color:#75715e>// we can now unlock as the work afterwards is thread-free
</span><span style=color:#75715e></span>        pthread_mutex_unlock(pool<span style=color:#f92672>-&gt;</span>lock);
        work<span style=color:#f92672>-&gt;</span>func(work<span style=color:#f92672>-&gt;</span>arg);
        free(work);
    }
    <span style=color:#66d9ef>return</span> NULL;
}
</code></pre></div><p>This is the main loop that every thread will keep executing until told to stop. In the beginning, we wait for the thread to get new work by using the <code>pthread_cond_wait</code> method inside the while loop. This way the thread sleeps and doesn&rsquo;t use excessive CPU while it randomly runs in the background without work. If we ever want to wake up the thread we can use the <code>pthread_cond_signal</code> (Java: <code>notify</code>) or <code>pthread_cond_broadcast</code> (Java: <code>notifyAll</code>) methods. We use the <code>work_cond</code> attribute to signal that new work has been added to the queue.</p><p>When the stop flag is marked we signal the <code>finished_cond</code> to mark that a thread has finished. We listen for this condition when we wait for all threads to finish.
Afterward, we simply take the next piece of workload and make sure to execute the work outside of the lock.</p><h3 id=t_pool_add_work class=anchor-link><a href=#t_pool_add_work>t_pool_add_work<span class=pilcrow>&nbsp;¶</span></a></h3><p>This is the function we use to add work to the queue.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>t_pool_add_work</span>(t_pool_t <span style=color:#f92672>*</span>tp, t_func func, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>arg) {
    <span style=color:#75715e>// creates the new work node
</span><span style=color:#75715e></span>    t_work_t <span style=color:#f92672>*</span>work <span style=color:#f92672>=</span> (t_work_t <span style=color:#f92672>*</span>)malloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> t_work));
    work<span style=color:#f92672>-&gt;</span>arg <span style=color:#f92672>=</span> arg;
    work<span style=color:#f92672>-&gt;</span>func <span style=color:#f92672>=</span> func;
    work<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> NULL;

    <span style=color:#75715e>// coarsely locks the queue
</span><span style=color:#75715e></span>    pthread_mutex_lock(tp<span style=color:#f92672>-&gt;</span>lock);
    t_work_t <span style=color:#f92672>*</span>last <span style=color:#f92672>=</span> tp<span style=color:#f92672>-&gt;</span>last_work;
    <span style=color:#66d9ef>if</span> (last)
        last<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> work;
    <span style=color:#66d9ef>else</span>
        tp<span style=color:#f92672>-&gt;</span>first_work <span style=color:#f92672>=</span> work;
    tp<span style=color:#f92672>-&gt;</span>last_work <span style=color:#f92672>=</span> work;
    tp<span style=color:#f92672>-&gt;</span>work_count<span style=color:#f92672>++</span>;
    pthread_cond_signal(tp<span style=color:#f92672>-&gt;</span>work_cond);
    pthread_mutex_unlock(tp<span style=color:#f92672>-&gt;</span>lock);

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
}
</code></pre></div><p>In this function, we first create the work structure which consists of the passed-in function pointer and a pointer to the data.
Once we have the work node, we enqueue it at the end of our pool queue and then signal one of the waiting threads that are sleeping, that there is new work to be done. I used a coarse lock here because it makes the implementation very simple and safe.</p><h3 id=t_pool_pop_work class=anchor-link><a href=#t_pool_pop_work>t_pool_pop_work<span class=pilcrow>&nbsp;¶</span></a></h3><p>With this function, we pop off the first element of the queue and return it.
Because we call this method in the <code>thread_work_loop</code> while we have a lock already, we don&rsquo;t need to lock in this method again. If this method was to be used elsewhere as well, I&rsquo;d add locking to avoid any problems.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C>t_work_t <span style=color:#f92672>*</span><span style=color:#a6e22e>t_pool_pop_work</span>(t_pool_t <span style=color:#f92672>*</span>tp) {
    <span style=color:#66d9ef>if</span> (tp<span style=color:#f92672>-&gt;</span>work_count <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
        <span style=color:#66d9ef>return</span> NULL;
    t_work_t <span style=color:#f92672>*</span>head <span style=color:#f92672>=</span> tp<span style=color:#f92672>-&gt;</span>first_work;
    <span style=color:#66d9ef>if</span> (head<span style=color:#f92672>-&gt;</span>next) <span style=color:#75715e>// there are still elements in the queue
</span><span style=color:#75715e></span>        tp<span style=color:#f92672>-&gt;</span>first_work <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
    <span style=color:#66d9ef>else</span> { <span style=color:#75715e>// we removed the last element in the queue
</span><span style=color:#75715e></span>        tp<span style=color:#f92672>-&gt;</span>first_work <span style=color:#f92672>=</span> NULL;
        tp<span style=color:#f92672>-&gt;</span>last_work <span style=color:#f92672>=</span> NULL;
    }
    tp<span style=color:#f92672>-&gt;</span>work_count<span style=color:#f92672>--</span>;
    <span style=color:#66d9ef>return</span> head;
}
</code></pre></div><p>Other than that the function is just a dequeue function like you would implement it in other singly-linked lists.</p><h3 id=t_pool_wait class=anchor-link><a href=#t_pool_wait>t_pool_wait<span class=pilcrow>&nbsp;¶</span></a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>t_pool_wait</span>(t_pool_t <span style=color:#f92672>*</span>tp) {
    pthread_mutex_lock(tp<span style=color:#f92672>-&gt;</span>lock);
    <span style=color:#66d9ef>while</span> (tp<span style=color:#f92672>-&gt;</span>thread_count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
        pthread_cond_wait(tp<span style=color:#f92672>-&gt;</span>finished_cond, tp<span style=color:#f92672>-&gt;</span>lock);
    pthread_mutex_unlock(tp<span style=color:#f92672>-&gt;</span>lock);
}
</code></pre></div><p>In this function, we simply wait for all threads to end. Because we don&rsquo;t keep track of all the threads, we can&rsquo;t just join on each thread. We instead do it differently and look at how many threads are still active. With how we created our <code>thread_work_loop</code> function, every thread that stops correctly reduces the <code>thread_count</code> and then signals the <code>finished_cond</code>. This means that if all threads end correctly the while loop is broken and we can finish waiting. This method will also wait forever if the threads are never told to stop.</p><p>This implementation has two flaws though. The first is that when a thread goes on holiday (for example it crashes) this function will wait forever. A way to circumvent this would be to use <code>pthread_cond_timedwait</code> instead and break out of the while loop once a certain limit is reached. If the time limit is too short, it can result in ignoring threads that are still alive but simply working.</p><p>The second is the fact that threads take some time to properly close. And threads that are still open when the main thread exits are considered a memory leak. This means that if we wait using this function and then instantly exit when this function ends, there&rsquo;s a good possibility that the worker threads didn&rsquo;t close down yet. If this is a big problem for you, usually waiting for like 1ms would fix it. The clean solution would be to join on the threads, but that means you have to store the thread pointers somewhere.</p><h3 id=t_pool_destroy class=anchor-link><a href=#t_pool_destroy>t_pool_destroy<span class=pilcrow>&nbsp;¶</span></a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>t_pool_destroy</span>(t_pool_t <span style=color:#f92672>*</span>tp) {
    pthread_mutex_lock(tp<span style=color:#f92672>-&gt;</span>lock);
    tp<span style=color:#f92672>-&gt;</span>stop <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#75715e>// delete all nodes still in the queue
</span><span style=color:#75715e></span>    t_work_t <span style=color:#f92672>*</span>cur <span style=color:#f92672>=</span> tp<span style=color:#f92672>-&gt;</span>first_work, <span style=color:#f92672>*</span>prev <span style=color:#f92672>=</span> NULL;
    <span style=color:#66d9ef>while</span> (cur) {
        prev <span style=color:#f92672>=</span> cur;
        cur <span style=color:#f92672>=</span> cur<span style=color:#f92672>-&gt;</span>next;
        <span style=color:#66d9ef>if</span> (prev)
            free(prev);
    }
    tp<span style=color:#f92672>-&gt;</span>work_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#75715e>// wakes up all sleeping threads
</span><span style=color:#75715e></span>    pthread_cond_broadcast(tp<span style=color:#f92672>-&gt;</span>work_cond);
    pthread_mutex_unlock(tp<span style=color:#f92672>-&gt;</span>lock);
    <span style=color:#75715e>// waits for all threads to finish
</span><span style=color:#75715e></span>    t_pool_wait(tp);
    <span style=color:#75715e>/* Freeing up all the attributes */</span>
}
</code></pre></div><p>This is our method to clean up all the memory we used, so we don&rsquo;t end up with tons of memory leaks in the end. The basic idea is that we first set <code>stop</code> to 1 which makes all the threads stop as soon as they can. We then clear up the whole queue and free up any work nodes that are still in there. In the end, we use <code>pthread_cond_broadcast</code> (Java: <code>notifyAll</code>) to wake up all the threads with the <code>work_cond</code> variable. It&rsquo;s like we&rsquo;re waking up all threads telling them there&rsquo;s more work to be done, but actually, we just woke them up to dump them. Once we waited for all threads to finish, we can clean up the rest of the attributes.</p><p>The freeing part can be seen <a href=https://github.com/markbeep/Disco-C/blob/master/libs/utils/t_pool.c#L103-L109>here</a>.</p><h3 id=t_process_count class=anchor-link><a href=#t_process_count>t_process_count<span class=pilcrow>&nbsp;¶</span></a></h3><p>Lastly, we simply have a quick helper method to get the number of processes we have available. This allows us to create the same amount of threads as the processes we have.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>t_process_count</span>() {
    <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>int</span>)sysconf(_SC_NPROCESSORS_ONLN);
}
</code></pre></div><h1 id=using-the-thread-pool class=anchor-link><a href=#using-the-thread-pool>Using the thread pool<span class=pilcrow>&nbsp;¶</span></a></h1><p>Now to how we can properly use the thread pool. A sample use case would look like so. First, we define the function that the worker thread should execute. We&rsquo;ll keep it simple and simply have the function take a string and print it to the console.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print_string</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> data) {
    printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)data);
    free(data);
}
</code></pre></div><p>We need to free the allocated data inside this function because we won&rsquo;t know on the outside when this thread is done with the work.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C>t_pool_t<span style=color:#f92672>*</span> pool <span style=color:#f92672>=</span> t_pool_init(t_process_count());
<span style=color:#75715e>/* we need to place the data on the heap, otherwise
</span><span style=color:#75715e>   it could be cleared up before the other thread
</span><span style=color:#75715e>   uses the data */</span>
<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> data <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)malloc(<span style=color:#ae81ff>12</span>);
strcpy(work, <span style=color:#e6db74>&#34;Hello World&#34;</span>);
t_pool_add_work(pool, <span style=color:#f92672>&amp;</span>print_string, data);

<span style=color:#75715e>// cleanup
</span><span style=color:#75715e></span>t_pool_destroy(pool);
</code></pre></div><p>This little implementation is already all we need. It adds the work to the pool, a thread will execute it right when we do <code>t_pool_add_work</code> and then with <code>t_pool_destroy</code> we wait for the message to be printed and then we clean up.</p><h1 id=final-words class=anchor-link><a href=#final-words>Final words<span class=pilcrow>&nbsp;¶</span></a></h1><p>I found this thread pool implementation a nice addition to my Discord library. I always wondered how a thread pool worked, but never really looked into the details. There are still a lot of additions that can be made which will make it faster and safer, but for now, this barebones version will work for me. I will probably add a timed wait in my wait function, but I still have to see how exactly I&rsquo;ll implement this so it works the way I need it to work.</p><p>If you got until here, awesome and thanks for reading! Hope I motivated you to also try looking into a function you&rsquo;ve been using at the top level, but never really checked how it works behind the hood.</p></div></article></div><nav role=navigation class="flex-container bottom-menu"><hr><p><script src=https://utteranc.es/client.js repo=markbeep/markbeep.github.io issue-term=pathname label=comments theme=dark-blue crossorigin=anonymous async></script><a href=/posts>back</a>
&#183;
<a href=/posts>posts</a>
&#183;
<a href=https://github.com/markbeep>github</a>
&#183;
<a href=/polyring>polyring</a>
&#183;
<a href=/about>who is mark?</a>
&#183;
<a href=/>main</a></p></nav></main><footer class="flex-container footer">Call me Sam, a theme for Hugo.</footer></body></html>